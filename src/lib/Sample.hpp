/**
 *  @ RSK
 *  @ Version 1.1        27.02.2010
 * 
 *  Classes to store samples (negative and positive) generated by 
 *  SampleGenerator class 
 * 
 *  A Sample is chosen from a Proposition (negative or positive)
 *  A Sample is associated to a Constituent token (for constituent-base
 *  arguments) and a Word token (for dependency-based arguments) via 
 *  that COnstituent token
 *  
 */

#ifndef SAMPLE_HPP
#define SAMPLE_HPP

#include <vector>

#include "Types.hpp"
#include "Constants.hpp"

using namespace std;


class Proposition;

class Sample
{
 private:

  Proposition *prop;
  Constituent cnstntToken;
  ArgLabel goldLabel;         // gold PropBank argument label
  
  // vectors to store predicted labels by system paired with their probability:
  // Each item of the array is related to a feature view. For self-training
  // the array length is 1 and for co-training it's equal to the number of
  // views (e.g. 2)
  vector<pair<ArgLabel, double> > prdLabels[FEATURE_VIEW_COUNT];          

  // no of the classifier predicting the current label for each feature view
  // e.g. classifierNo[1] = 9 means that the label for feature view 1 has
  // been predicted by the classifier with no 9 of that view;
  // useful when verifying the convergence
  short classifierNo[FEATURE_VIEW_COUNT];
  
  // selected prdLabel for the sample from among prdLabels via any selection
  // strategy 
  // used in co-training for 2 purposes:
  // 1. labeling test data with common labels between views (in addition 
  //    to with each view)
  // 2. training views on common labels (with common-training-set co-training
  //    method)
  pair<ArgLabel, double> selPrdLabel;          
  
  // Each item of the array is related to a feature view. For self-training
  // the array length is 1 and for co-training it's equal to the number of
  // views (e.g. 2)
  unsigned short activeFeatureSets[FEATURE_VIEW_COUNT];
  
  // Each item of the array is related to a feature view. For self-training
  // the array length is 1 and for co-training it's equal to the number of
  vector<pair<string, string> > featureVectors[FEATURE_VIEW_COUNT];
  
 public:

  Sample(Proposition * const &, Constituent &, 
         unsigned short, unsigned short [],  
         ArgLabel &, ofstream &);
  
  Proposition *getProp();
  string getPredForm();
  string getCnstntLabel();
  Constituent getCnstntToken();
  WordSpan getWordSpan();
  string getWordsStr();
  ArgLabel getGoldArgLabel();
  // returns the predicted label with highest confidence for the given view
  ArgLabel getPrdArgLabel(unsigned short);
  // returns the most likely predicted argument's probability for the given view
  double getPrdArgLabelProb(unsigned short);
  // returns the average probability of label predictions by all views 
  double getAvgPrdArgLabelProb();
  // returns the predicted label with highest confidence for the given view
  // if predicted label has been assigned. Otherwise, returns gold label. 
  // (used for bootstrapping in where both labeled and predicted samples are mixed)
  ArgLabel getPrdOrGoldArgLabel(unsigned short);
  bool setPrdArgLabels(vector<pair<ArgLabel, double> > &, unsigned short, 
                       unsigned short, bool);
  // returns the no of classifier for the given feature view, which has
  // predicted the current label of the sample
  short getClassifierNo(unsigned short);
  void setSelPrdLabel(ArgLabel, double);
  ArgLabel getSelPrdLabel();
  double getSelPrdLabelProb();
  void setSelectedPrdLabel(unsigned short, unsigned short);
  ArgLabel getMCPrdLabel();
  double getMCPrdLabelProb();
  // returns whether this sample is labeled as non-NULL argument or NULL
  // (non-Argument) for the given view
  bool isPrdArgument(unsigned short);
  bool isPrdCoreArg(unsigned short);
  // checks whether predicated labeles are identical through all views
  // (agreed upon)
  bool isPrdArgLabelsAgreed();
  // checks, finds, and resolve global SRL constraints
  void resolveConstraints(vector<pair<ArgLabel, double> > &, unsigned short);
  bool isOverlapped(Sample &);

  void extractFeatures(unsigned short);
  // to conveniently try a new feature
  string extractTrialFeature();
  string extractPhraseType();
  string extractPosition();
  string extractPredLemma();
  string extractPredPOS();
  string extractPredVoice();
  string extractPath();
  string extractPathLength(unsigned short);
  string extractCVNCountInPath(unsigned short);
  string extractHeadWord();
  string extractContentWord();
  string extractHeadWordLemma();
  string extractContentWordLemma();
  string extractHeadWordPOS();
  string extractContentWordPOS();
  string extractPredSubcat();
  string extractCnstntSubcat();
  string extractGovCat();
  string extractCPDistance();
  string extractCPIdentifier();
  string extractHWLocation();
  string extractPredForm();
  string extractAWForm();
  string extractAWRel();
  string extractPredRel();
  string extractAWHeadForm();
  string extractAWHeadLemma();
  string extractAWHeadPOS();
  string extractPredChildrenRP();
  string extractAWChildrenRP();
  string extractPredChildrenPP();
  string extractAWChildrenPP();
  string extractRelPath();
  string extractARelPath();
  string extractPOSPath();
  string extractAPOSPath();
  string extractFamilyRelation();
  string extractPredSiblingsRP();
  string extractPredSiblingsPP();
  string extractPredParentSiblingsRP();
  string extractPredParentSiblingsPP();
  string extractAWSiblingsRP();
  string extractAWSiblingsPP();
  string extractAWParentSiblingsRP();
  string extractAWParentSiblingsPP();
  string extractAWLRChildrenForms();
  string extractAWLSiblingForm();
  string extractLCommonAncestorPOS();
  string extractAWRelPathToLCA();
  string extractAWPOSPathToLCA();
  string extractDepPathLength(unsigned short);
  string extractLemmaPath();
  string extractAWLemmaPathToLCA();
  string extractLSARelPathToRoot();
  string extractLSAPOSPathToRoot();
  string extractDividedDepPathLength(unsigned short);
  string extractIsCapital(); 
  string extractIsWH(); 
  
  void getZMEContext(vector<string> &, unsigned short);
  string getZMEContextStr(unsigned short);
  void writeToZME(unsigned short, ofstream &);
  void logPrdLabeling(unsigned short, ofstream &);
  void logPrdLabelings(unsigned short, ofstream &);

};

#endif /* SAMPLE_HPP */
